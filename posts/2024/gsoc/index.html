<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Google Summer of Code 2024 - Multigrid for FEniCSx | schnellerhase</title><meta name=keywords content><meta name=description content="Intro This is the report on the Google Summer of Code 2024 project, entitled &lsquo;Multigrid for FEniCSx&rsquo;, under the auspices of the NumFOCUS organization, on the FEniCS Project, which is (since 2016) fiscally supported by NumFOCUS.
Under the supervision of Jack S. Hale (Research Scientist, University of Luxembourg), Chris Richardson (Research Software Engineer, University of Cambridge) and Joseph Dean (Research Scientist, University of Cambridge) the Google Summer of Code provided an opportunity for me to contribute to the FEniCS project and get to know open source software development efforts for high-performance computing applications."><meta name=author content="schnellerhase"><link rel=canonical href=https://schnellerhase.github.io/posts/2024/gsoc/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://schnellerhase.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://schnellerhase.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://schnellerhase.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://schnellerhase.github.io/apple-touch-icon.png><link rel=mask-icon href=https://schnellerhase.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js integrity=sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="Google Summer of Code 2024 - Multigrid for FEniCSx"><meta property="og:description" content="Intro This is the report on the Google Summer of Code 2024 project, entitled &lsquo;Multigrid for FEniCSx&rsquo;, under the auspices of the NumFOCUS organization, on the FEniCS Project, which is (since 2016) fiscally supported by NumFOCUS.
Under the supervision of Jack S. Hale (Research Scientist, University of Luxembourg), Chris Richardson (Research Software Engineer, University of Cambridge) and Joseph Dean (Research Scientist, University of Cambridge) the Google Summer of Code provided an opportunity for me to contribute to the FEniCS project and get to know open source software development efforts for high-performance computing applications."><meta property="og:type" content="article"><meta property="og:url" content="https://schnellerhase.github.io/posts/2024/gsoc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-30T12:00:00+02:00"><meta property="article:modified_time" content="2024-08-30T12:00:00+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Google Summer of Code 2024 - Multigrid for FEniCSx"><meta name=twitter:description content="Intro This is the report on the Google Summer of Code 2024 project, entitled &lsquo;Multigrid for FEniCSx&rsquo;, under the auspices of the NumFOCUS organization, on the FEniCS Project, which is (since 2016) fiscally supported by NumFOCUS.
Under the supervision of Jack S. Hale (Research Scientist, University of Luxembourg), Chris Richardson (Research Software Engineer, University of Cambridge) and Joseph Dean (Research Scientist, University of Cambridge) the Google Summer of Code provided an opportunity for me to contribute to the FEniCS project and get to know open source software development efforts for high-performance computing applications."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://schnellerhase.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Google Summer of Code 2024 - Multigrid for FEniCSx","item":"https://schnellerhase.github.io/posts/2024/gsoc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Google Summer of Code 2024 - Multigrid for FEniCSx","name":"Google Summer of Code 2024 - Multigrid for FEniCSx","description":"Intro This is the report on the Google Summer of Code 2024 project, entitled \u0026lsquo;Multigrid for FEniCSx\u0026rsquo;, under the auspices of the NumFOCUS organization, on the FEniCS Project, which is (since 2016) fiscally supported by NumFOCUS.\nUnder the supervision of Jack S. Hale (Research Scientist, University of Luxembourg), Chris Richardson (Research Software Engineer, University of Cambridge) and Joseph Dean (Research Scientist, University of Cambridge) the Google Summer of Code provided an opportunity for me to contribute to the FEniCS project and get to know open source software development efforts for high-performance computing applications.","keywords":[],"articleBody":"Intro This is the report on the Google Summer of Code 2024 project, entitled ‘Multigrid for FEniCSx’, under the auspices of the NumFOCUS organization, on the FEniCS Project, which is (since 2016) fiscally supported by NumFOCUS.\nUnder the supervision of Jack S. Hale (Research Scientist, University of Luxembourg), Chris Richardson (Research Software Engineer, University of Cambridge) and Joseph Dean (Research Scientist, University of Cambridge) the Google Summer of Code provided an opportunity for me to contribute to the FEniCS project and get to know open source software development efforts for high-performance computing applications.\nThe FEniCS project’s primary component is the finite element solving environment, DOLFINx, on which the majority of the project’s work was conducted. The “x” indicates that this is a new version, which supersedes the former (now legacy) DOLFIN. Although the objective of both the legacy and current projects is identical, the necessity to adapt to new requirements, incorporate new technological advances and, integrate insights gained from previous experiences has prompted the decision to rewrite and redesign the project in a new version.\nGeometric Multigrid and an Application to GSOC Let us for this section reference the proposal of the project, which explains the project’s goals.\nPrevious Next / [pdf] View the PDF file here. Implementation decisions As an initial step in the research and familiarization phase, it was essential to figure assess the objectives of the FEniCS project with regard to a geometric multigrid implementation. The interaction between this novel feature and existing ones, as well as the design principles of the DOLFINx code base played a major role during this phase. Let us briefly revisit the findings and their implications for the project.\nOne of the fundamental design decisions of DOLFINx (also in contrast to its predecessor) is the incorporation of a data-driven design principle. Functionality should be provided on standard data containers holding the necessary information, without further encapsulation and object based data wrapping, while implicit expectations on data or objects are to be kept to a minimum. The primary rationale for this approach is to facilitate the extension of usability and functionality beyond the initially conceived scope of a given feature.\nFor the multigrid implementation this resulted, after careful consideration, in the decision to make the transfer operation itself an explicit function that needs to be provided explicitly for a specific use case. This represents a different approach than that taken by other software, such as Firedrake (see here) and PETSc (see here), which employ an implicit construction of transfer operations. Moreover, the mesh hierarchies to be considered in this project should be generated by the available refinement routines (based on the work of Plaza), and not be applicable to general meshes without clear containment.\nIn addition to providing greater clarity for the user, the design should also, in principle, facilitate enhanced performance, or at the very least, more precise control over it. This is because features are not utilized unless they have been employed by the user.\nNevertheless these specializations will not allow us to adress the discussed shared properties of geometric multigrid with $p$-multigrid and domain decomposition methods. This should be a relatively straightforward process to implement once the geometric multigrid method has been implemented.\nInterpolation Operators and Dual Operators A first idea to approach the implementation of a geometric multigrid with the hope of an easy to attain proof of concept, came with the availability of the non-matching mesh interpolation routine of DOLFINx. This routine implements a general interpolation operation between non matching meshes, and thus also non-matching, function spaces in general. So we have already the implementation at hand to produce for two different finite element approximation spaces $V_\\text{coarse}$ and $V_\\text{fine}$ mappings So a first approach might be to make use of these mappings for a first geometric multigrid implementation and refine it after. Nevertheless, a more detailed examination reveals an inherent and irremediable defect in this setup.\nLet us consider an one dimensional example.\n$$ V_\\text{coarse} = P^1 ( \\left\\lbrace 0, 1 \\right\\rbrace ) \\quad \\text{and} \\quad V_\\text{fine} = P^1 \\left( \\left\\lbrace 0, \\frac{1}{2}, 1 \\right\\rbrace \\right) $$\nwith the non matching interpolations as restriction $R : V_\\text{fine} \\to V_\\text{coarse}$ and prolongation $P : V_\\text{coarse} \\to V_\\text{fine}$ operators, i.e.\n$$ P = \\begin{bmatrix} 1 \u0026 0 \\newline \\frac{1}{2} \u0026 \\frac{1}{2} \\newline 0 \u0026 1 \\end{bmatrix} \\quad \\text{and} \\quad R = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\newline 0 \u0026 0 \u0026 1 \\end{bmatrix} $$\nEspecially the map $P$ is injective and $R$ is surjective, which fits our expectations. But we loose one very important property that we require for transfer operators. The restriction should be the adjoint of the prolongation, i.e. (for matrices)\n$$ R = P^T \\iff P = R^T. $$\nFor the example this is not the case. This breaks the properties of the multigrid operator - for example without duality we loose every mathematical ground of proving any properties of the multigrid operator matrix, such as for example the for convergence critical spectral radius.\nTesting Discrete Adjoint Operators The subtleties around the adjoint property do need end with this. The requirement of the adjointness on the transfer operators and the implications on coefficients of the transferred functions preclude the possibility of recovering function scaling Consequently, it is not feasible to expect that a combination of interpolations between the two spaces will yield a suitable transfer operator combination..\nFurthermore, this suggests that meticulous attention must be paid to the criteria employed during the assessment of transfer operators, particularly with regard to the verification of implementations. To illustrate, the constant one function is not recovered after it has been restricted and prolonged with suitable operators. This is a consequence of our focus on the transfer of the residual, that is, an element of the dual space, not a function.\nAn Interval Refinement Routine for DOLFINx The logical step to start with a geometric multigrid in the context of mesh hierarchies generated by refinement routines is, of course, the one-dimensional case, i.e. interval meshes. However DOLFINx did not provide any such routine at that time. So as a first major step, the implementation of a one-dimensional refinement routine was addressed, which resulted in a (merged) pull request.\nLet us consider a small example to illustrate what we need to do. Given a mesh consisting of three vertices (bold) and two cells (or equivalently edges)\n0 — 0 — 1 — 1 — 2 — 2 — 3,\nwe want to perform a refinement on a set of marked edges $M$. Let us first consider the case of uniform refinement, so we mark all edges for refinement, i.e. $M=\\{ 0, 1, 2 \\}$. While in higher dimensions mesh refinement offers a great number of applicable refinement schemes to refine a marked edge, in one dimension the necessary operation is unique. Each marked edge is to be split, i.e. a new vertex is to be introduced in the center and the former edge is to be split into two new finer/shorter edges. For the former mesh we thus expect the fine mesh\n0 — 0 — 1 — 1 — 2 — 2 — 3 — 3 — 4 — 4 — 5 — 5 — 6.\nAt first glance, this seems like a very straightforward operation to implement, but a few caveats arising from parallel data structures with relabeling of indexes for locality and the for parallel use cases inevitable repartitioning make it surprisingly sophisticated to implement.\nFor the debugging of the code, especially in parallel, looking at visualizations of the meshes before and after refinement was a crucial step. This was easy to do thanks to the handy febug tool, which makes visualizing different mesh entities straightforward and easy.\nComing soon: detailed exaplanation of the algorithm introduced in PR 3314 including data stored in parallel, algorithm employed and output (parent cells)\nA Story on Assertions in Compiled Python Modules After discovering an initial bug in the merged code, resulting in an obscure crash of a Python test, we discovered a problem in the interaction with assertions and the Python runtime. The bug was caused by the code hitting an assertion in the C++ part of the software, correctly due to a poorly designed test case. However the pytest framework, which is used for unit and integration testing in the FEniCS project, did not catch this and only showed an inconclusive core dump. This turned out to be a major and not trivially fixable problem. If the C++ part, i.e. in a call of the compiled Python module, encounters an C-style assertion the runtime itself is killed, as this triggers a call to ´abort´. In particular, the handling of the assertion is not passed back to the outer Python context which has systems in place to recover from this. Since abort produces a SIGABRT signal that forcibly exits the program there is no easy way to fix this interaction. However, if the Python module (i.e. the C++ code) is built in a Debug mode we would like to be able to debug from the Python side as well, which is then no longer possible. This needs to be investigated further and remains an open issue.\nUnifying the Refinement Interface After merging the one-dimensional refinement routine, we wanted to merge its interface with the previously available two- and three-dimensional Plaza refinement routines. This resulted in many changes and simplifications to the interface. It became more explicit and easier to use, resulting in an (open) pull request.\nOne technical change that was introduced to facilitate this was the use of std::optional’s for input and output parameters. Previously these were not used and a ’no-set’ case was always handled separately leading to multiple different code paths. In addition, this dispatching had to be present in the python module as well. However, Nanobind (the Python exporter used in the DOLFINx project) however supports the std::optionals matching from the python optional None or value style for this. So after the change, we no longer need to handle different parameter combinations in the Python module, this is all done in the C++ module. These changes are part of another (open) pull request.\nThe Transfer Matrix Coming soon: parallelization and ghost nodes, graph partitioning\nDebugging a Parallel CSR Matrix Compressed Sparse Row Major (CSR) matrices are a great data format for efficient computations and FEM matrix assemblies. However, the data format is not easy to debug or visualize. For debugging purposes the DOLFINx CSR matrix implementation has a to_dense functionality that translates the CSR format into a dense representation of the matrix for debugging purposes. However, this functionality only really supported sequential calls, and dropped quite a bit of information in parallel runs. Let us recap what the functionality used to provide and present its new functionality.\nGiven two parallel partitions $I = (i_0, \\dots, i_n)$ and $J = (j_0, \\dots, j_n)$ associated with the row and column distribution across the ranks, i.e. the process $p$, for some $0 \\leq p \u003c n$, owns rows $[i_p, i_{p+1})$ and columns $[j_p, j_{p+1})$. The to_dense function produced the dense subblock of the global matrix $A = (a_{ij})_{0\\leq i \u003c i_n,\\ 0 \\leq j \\leq j_n}$ which was strictly global, i.e. the submatrix\n$$ \\begin{bmatrix} a_{i_p, j_p} \u0026 \\dots \u0026 a_{i_p, j_{p+1}} \\newline \\vdots \u0026 \\ddots \u0026 \\vdots \\newline a_{i_{p+1}, j_p} \u0026 \\dots \u0026 a_{i_{p+1}, j_{p+1}} \\end{bmatrix}. $$\nHowever, this functionality drops from the dense representation all entries that are part of the local entries, and thus available on the given process rank $p$, that are in columns not owned by the current process $p$. After the proposed changes to_dense now returns a dense representation of all locally owned rows (over all global columns), i.e. the submatrix we get on process $p$ is then\n$$ \\begin{bmatrix} a_{i_p, 0} \u0026 \\dots \u0026 a_{i_p, j_n} \\newline \\vdots \u0026 \\ddots \u0026 \\vdots \\newline a_{i_{p+1}, 0} \u0026 \\dots \u0026 a_{i_{p+1}, j_n} \\end{bmatrix}. $$\nThese changes are part of a (open) pull request and are required for debugging and testing the transfer matrix implementation alike.\nGeometric Twogrid Example Coming soon…\nGeneral Code Contributions While the primary objective was the implementation of a geometric multigrid, a number of additional changes were made to different repositories. These changes are outlined below in chronological order.\nDOLFINx - Introduce Aliasing for mdspan (Closed) The mdspan library utilized by the FEniCS Project is based on the Kokkos reference implementation. To streamline the namespace switching process, depending on compiler support for either std::experimental::mdspan or std::mdspan, or no support at all the implementation introduces the macro MDSPAN_IMPL_STANDARD_NAMESPACE. This results in unnecessarily lengthy calls, as it requires the repeated writing out of MDSPAN_IMPL_STANDARD_NAMESPACE::mdspan each time mdspan is used In the pull request, the suggestion was to wrap this into a custom hiding layer, allowing for access via dolfinx::common::mdspan, regardless of what this dispatches to. This approach would also enable the code to remain unchanged in the event of an STL version update. Following a discussion, the proposed changes were rejected on the grounds that they constituted an approximation of a third-party library.\nBasix - Update mdspan (Merged) Update to new Kokkos single header mdspan changes.\nDOLFINx - Make compile time options compile time constants (Merged) Previously, the transformation of compiler flags in translation units was moved to header files in combination with the usage of consteval, which effectively made them true compile time constants. The following example illustrates the idiom of the changes for a given CMake flag.\nconsteval bool has_flag() { #ifdef FLAG return true; #else return false; #endif } DOLFINx - Some updates for mesh generation (Open) While researching mesh-related data structures in DOLFINx for the project, I discovered several suboptimal code paths in the mesh generation code. This PR addresses these issues, primarily through modernization, simplification, and additional testing. The modernizations also made use of the previously (in the FEniCS Project) unused ranges library, this was the trigger for looking into further use cases of it, resulting in the following 12 pull requests.\nBasix - Update to std::ranges usage (Merged) Made use of all C++20 available ranges algorithms in the Basix code base.\nBasix - C++23 Support (Reverted) Some important parts of the ranges library were missed in C++20, and are only available from C++23 onward. So to check general compatibility of the FEniCS packages with C++23 we looked into the root dependency Basix and confirmed that we it is C++23 ready in this PR. This move to the C++23 standard was later on reverted, and it was decided on to (not yet) switch to C++23 but remain with C++20 for now mainly due to lacking compiler support.\nDOLFINx - Update to std::ranges usage Modernization to range based algorithms across all of DOLFINx, split up into several PR’s:\nReplace std::sort with std::ranges::sort (Merged) Replace std::fill with std::ranges::fill (Merged) Replace std::lower/uper_bound with std::ranges::lower/uper_bound (Merged) Replace std::for_each with std::ranges::for_each (Merged) Replace std::transform with std::ranges::transform (Merged) Replace std::set_* with std::ranges::set_* (Merged) Replace std::copy with std::ranges::copy (Merged) Replace std::min/max with std::ranges::min/max (Merged) Replace std::unique with std::ranges::unique (Merged) Rework radix_sort (Merged) During the process of updating from std::sort to std::ranges::sort, it was observed that the custom DOLFINx implementation of radix sort radix_sort (which is utilized for performance-critical sorting of degree of freedom indices primarily) is not compatible with the ranges interface. This pull request introduces a range-based radix_sort, which offers the same functionality as std::ranges::sort. To achieve this, the operator-based approach used in the ranges library was followed, and a projection routine for the elements can be added. This allowed for the removal of the previously hand-coded argsort_radix in DOLFINx, leaving only one instance of the radix_sort functionality. Given its performance-critical nature, the changes were benchmarked here. The results demonstrated that the higher-quality code is also the faster one.\nFavor exterior_facet_indices over locate_entities_boundary for retrieving complete boundary (Merged) This pull request addresses the observation that when all boundary entities need to be selected in FEniCSx to construct a Dirichlet boundary condition on them, it is not necessary to filter these with a specific lambda as the default interface of locate_entities_boundary requires. Instead, the exterior_facet_indices can be used, which simply returns all boundary facets. This resulted in a (still ongoing) discussion on optional arguments in the DOLFINx code base and their implications for the exported Python module.\nStrictly Maintenance PR’s DOLFINx - Fix ruff check (Merged) febug - Fix installation with dolfinx main (Merged) FEniCS/web - Fix CI (Merged) Acknowledgements I would like to express my gratitude to the following individuals and institutions for their support and contributions:\nFirstly I would like to the (previously mentioned) supervisors of the GSOC project, for their kind welcome to the community and receptivity to new ideas, as well as for fostering a generally constructive and engaging atmosphere for discussion.\nI am indepted to Henrik N. Finsberg (Senior Research Engineer, Simula Research Laboratory) and Jørgen S. Dokken (Senior Research Engineer, Simula Research Laboratory) for acting as my initial point of contact with the FEniCS project and for making me aware of the possibilty of a GSOC project.\nFurthermore, I would be remiss if I did not acknowledge the contributions of all community members who provided assistance on the Slack channel or through comments and feedback on various pull requests.\nDuring the GSOC period, I was fortunate to attend the FEniCS conference 2024, which I was able to do with the assistance of a NumFOCUS travel award. Otherwise, it would not have been feasible to interact with all of the mentors and community members who were present in person.\nIn conclusion, I would like to express my gratitude to the Google Summer of Code program for providing me with the opportunity and financial support, which enabled me to pursue my academic interests and enhance my technical abilities with minimal constraints.\n","wordCount":"2951","inLanguage":"en","datePublished":"2024-08-30T12:00:00+02:00","dateModified":"2024-08-30T12:00:00+02:00","author":[{"@type":"Person","name":"schnellerhase"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://schnellerhase.github.io/posts/2024/gsoc/"},"publisher":{"@type":"Organization","name":"schnellerhase","logo":{"@type":"ImageObject","url":"https://schnellerhase.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://schnellerhase.github.io/ accesskey=h title="schnellerhase (Alt + H)">schnellerhase</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://schnellerhase.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://schnellerhase.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://schnellerhase.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://schnellerhase.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Google Summer of Code 2024 - Multigrid for FEniCSx</h1><div class=post-meta><span title='2024-08-30 12:00:00 +0200 +0200'>August 30, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;schnellerhase</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#geometric-multigrid-and-an-application-to-gsoc aria-label="Geometric Multigrid and an Application to GSOC">Geometric Multigrid and an Application to GSOC</a></li><li><a href=#implementation-decisions aria-label="Implementation decisions">Implementation decisions</a></li><li><a href=#interpolation-operators-and-dual-operators aria-label="Interpolation Operators and Dual Operators">Interpolation Operators and Dual Operators</a><ul><li><a href=#testing-discrete-adjoint-operators aria-label="Testing Discrete Adjoint Operators">Testing Discrete Adjoint Operators</a></li></ul></li><li><a href=#an-interval-refinement-routine-for-dolfinx aria-label="An Interval Refinement Routine for DOLFINx">An Interval Refinement Routine for DOLFINx</a><ul><li><a href=#a-story-on-assertions-in-compiled-python-modules aria-label="A Story on Assertions in Compiled Python Modules">A Story on Assertions in Compiled Python Modules</a></li><li><a href=#unifying-the-refinement-interface aria-label="Unifying the Refinement Interface">Unifying the Refinement Interface</a></li></ul></li><li><a href=#the-transfer-matrix aria-label="The Transfer Matrix">The Transfer Matrix</a><ul><li><a href=#debugging-a-parallel-csr-matrix aria-label="Debugging a Parallel CSR Matrix">Debugging a Parallel CSR Matrix</a></li></ul></li><li><a href=#geometric-twogrid-example aria-label="Geometric Twogrid Example">Geometric Twogrid Example</a></li><li><a href=#general-code-contributions aria-label="General Code Contributions">General Code Contributions</a><ul><li><a href=#dolfinx---introduce-aliasing-for-mdspan-closedhttpsgithubcomfenicsdolfinxpull3116 aria-label="DOLFINx - Introduce Aliasing for mdspan (Closed)">DOLFINx - Introduce Aliasing for mdspan (Closed)</a></li><li><a href=#basix---update-mdspan-mergedhttpsgithubcomfenicsbasixpull840 aria-label="Basix - Update mdspan (Merged)">Basix - Update mdspan (Merged)</a></li><li><a href=#dolfinx---make-compile-time-options-compile-time-constants-mergedhttpsgithubcomfenicsdolfinxpull3246 aria-label="DOLFINx - Make compile time options compile time constants (Merged)">DOLFINx - Make compile time options compile time constants (Merged)</a></li><li><a href=#dolfinx---some-updates-for-mesh-generation-openhttpsgithubcomfenicsdolfinxpull3275 aria-label="DOLFINx - Some updates for mesh generation (Open)">DOLFINx - Some updates for mesh generation (Open)</a></li><li><a href=#basix---update-to-stdranges-usage-mergedhttpsgithubcomfenicsbasixpull837 aria-label="Basix - Update to std::ranges usage (Merged)">Basix - Update to std::ranges usage (Merged)</a></li><li><a href=#basix---c23-support-revertedhttpsgithubcomfenicsbasixpull838 aria-label="Basix - C++23 Support (Reverted)">Basix - C++23 Support (Reverted)</a></li><li><a href=#dolfinx---update-to-stdranges-usage aria-label="DOLFINx - Update to std::ranges usage">DOLFINx - Update to std::ranges usage</a></li><li><a href=#rework-radix_sort-mergedhttpsgithubcomfenicsdolfinxpull3313 aria-label="Rework radix_sort (Merged)">Rework radix_sort (Merged)</a></li><li><a href=#favor-exterior_facet_indices-over-locate_entities_boundary-for-retrieving-complete-boundary-mergedhttpsgithubcomfenicsdolfinxpull3283 aria-label="Favor exterior_facet_indices over locate_entities_boundary for retrieving complete boundary (Merged)">Favor exterior_facet_indices over locate_entities_boundary for retrieving complete boundary (Merged)</a></li><li><a href=#strictly-maintenance-prs aria-label="Strictly Maintenance PR&rsquo;s">Strictly Maintenance PR&rsquo;s</a></li></ul></li><li><a href=#acknowledgements aria-label=Acknowledgements>Acknowledgements</a></li></ul></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>This is the report on the Google Summer of Code 2024 project, entitled <a href=https://summerofcode.withgoogle.com/programs/2024/projects/YhEwl8iB>&lsquo;Multigrid for FEniCSx&rsquo;</a>, under the auspices of the <a href=https://numfocus.org/>NumFOCUS</a> organization, on the <a href=https://fenicsproject.org/>FEniCS Project</a>, which is (since 2016) fiscally supported by NumFOCUS.</p><p>Under the supervision of <a href=https://www.jackhale.co.uk/>Jack S. Hale</a> (Research Scientist, University of Luxembourg), <a href=https://www.ieef.cam.ac.uk/user/cnr12>Chris Richardson</a> (Research Software Engineer, University of Cambridge) and <a href=https://www.eng.cam.ac.uk/profiles/jpd62>Joseph Dean</a> (Research Scientist, University of Cambridge) the Google Summer of Code provided an opportunity for me to contribute to the FEniCS project and get to know open source software development efforts for high-performance computing applications.</p><p>The FEniCS project&rsquo;s primary component is the finite element solving environment, <a href=https://doi.org/10.5281/zenodo.10447666>DOLFINx</a>, on which the majority of the project&rsquo;s work was conducted.
The &ldquo;x&rdquo; indicates that this is a new version, which supersedes the former (now legacy) <a href=https://doi.org/10.11588/ans.2015.100.20553>DOLFIN</a>.
Although the objective of both the legacy and current projects is identical, the necessity to adapt to new requirements, incorporate new technological advances and, integrate insights gained from previous experiences has prompted the decision to rewrite and redesign the project in a new version.</p><h2 id=geometric-multigrid-and-an-application-to-gsoc>Geometric Multigrid and an Application to GSOC<a hidden class=anchor aria-hidden=true href=#geometric-multigrid-and-an-application-to-gsoc>#</a></h2><p>Let us for this section reference the proposal of the project, which explains the project&rsquo;s goals.</p><script type=text/javascript src=/js/pdf-js/build/pdf.js></script><style>#embed-pdf-container{position:relative;width:100%;height:auto;min-height:20vh}.pdf-canvas{border:1px solid #000;direction:ltr;width:100%;height:auto;display:none}#the-canvas{border:1px solid #000;direction:ltr;width:100%;height:auto;display:none}.pdf-loadingWrapper{display:none;justify-content:center;align-items:center;width:100%;height:350px}.pdf-loading{display:inline-block;width:50px;height:50px;border:3px solid #d2d0d0;border-radius:50%;border-top-color:#383838;animation:spin 1s ease-in-out infinite;-webkit-animation:spin 1s ease-in-out infinite}#overlayText{word-wrap:break-word;display:grid;justify-content:end}#overlayText a{position:relative;top:10px;right:4px;color:#000;margin:auto;background-color:#eee;padding:.3em 1em;border:solid 2px;border-radius:12px;border-color:#00000030;text-decoration:none}#overlayText svg{height:clamp(1em,2vw,1.4em);width:clamp(1em,2vw,1.4em)}@keyframes spin{to{-webkit-transform:rotate(360deg)}}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}</style><div class=embed-pdf-container id=embed-pdf-container-4b9aee19><div class=pdf-loadingWrapper id=pdf-loadingWrapper-4b9aee19><div class=pdf-loading id=pdf-loading-4b9aee19></div></div><div id=overlayText><a href=/gsoc-proposal.pdf aria-label=Download download><svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18"><path d="M9 13c.3.0.5-.1.7-.3L15.4 7 14 5.6l-4 4V1H8v8.6l-4-4L2.6 7l5.7 5.7c.2.2.4.3.7.3zm-7 2h14v2H2z"/></svg></a></div><canvas class=pdf-canvas id=pdf-canvas-4b9aee19></canvas></div><div class=pdf-paginator id=pdf-paginator-4b9aee19><button id=pdf-prev-4b9aee19>Previous</button>
<button id=pdf-next-4b9aee19>Next</button> &nbsp; &nbsp;
<span><span class=pdf-pagenum id=pdf-pagenum-4b9aee19></span> / <span class=pdf-pagecount id=pdf-pagecount-4b9aee19></span></span>
<a class=pdf-source id=pdf-source-4b9aee19 href=/gsoc-proposal.pdf>[pdf]</a></div><noscript>View the PDF file <a class=pdf-source id=pdf-source-noscript-4b9aee19 href=/gsoc-proposal.pdf>here</a>.</noscript><script type=text/javascript>(function(){c="/gsoc-proposal.pdf",u="true"==="true",l=""==="true",h=parseInt("1")||1,s=window["pdfjs-dist/build/pdf"],s.GlobalWorkerOptions.workerSrc==""&&(s.GlobalWorkerOptions.workerSrc="https://schnellerhase.github.io/js/pdf-js/build/pdf.worker.js");var s,c,l,u,h,n=null,e=h,i=!1,o=null,b=3,t=document.getElementById("pdf-canvas-4b9aee19"),m=t.getContext("2d"),f=document.getElementById("pdf-paginator-4b9aee19"),r=document.getElementById("pdf-loadingWrapper-4b9aee19");v(),g();function a(e){i=!0,n.getPage(e).then(function(e){var s,r,n=e.getViewport({scale:b});t.height=n.height,t.width=n.width,s={canvasContext:m,viewport:n},r=e.render(s),r.promise.then(function(){i=!1,p(),o!==null&&(a(o),o=null)})}),document.getElementById("pdf-pagenum-4b9aee19").textContent=e}function p(){r.style.display="none",t.style.display="block"}function g(){if(l)return;r.style.display="flex",t.style.display="none"}function v(){if(u)return;f.style.display="block"}function d(e){i?o=e:a(e)}function j(){if(e<=1)return;e--,d(e)}document.getElementById("pdf-prev-4b9aee19").addEventListener("click",j);function y(){if(e>=n.numPages)return;e++,d(e)}document.getElementById("pdf-next-4b9aee19").addEventListener("click",y),s.getDocument(c).promise.then(function(t){n=t;var s=n.numPages;document.getElementById("pdf-pagecount-4b9aee19").textContent=s,e>s&&(e=s),a(e)})})()</script><h2 id=implementation-decisions>Implementation decisions<a hidden class=anchor aria-hidden=true href=#implementation-decisions>#</a></h2><p>As an initial step in the research and familiarization phase, it was essential to figure assess the objectives of the FEniCS project with regard to a geometric multigrid implementation.
The interaction between this novel feature and existing ones, as well as the design principles of the DOLFINx code base played a major role during this phase.
Let us briefly revisit the findings and their implications for the project.</p><p>One of the fundamental design decisions of DOLFINx (also in contrast to its predecessor) is the incorporation of a data-driven design principle.
Functionality should be provided on standard data containers holding the necessary information, without further encapsulation and object based data wrapping, while implicit expectations on data or objects are to be kept to a minimum.
The primary rationale for this approach is to facilitate the extension of usability and functionality beyond the initially conceived scope of a given feature.</p><p>For the multigrid implementation this resulted, after careful consideration, in the decision to make the transfer operation itself an explicit function that needs to be provided explicitly for a specific use case.
This represents a different approach than that taken by other software, such as Firedrake (see <a href=https://www.firedrakeproject.org/demos/geometric_multigrid.py.html>here</a>) and PETSc (see <a href=https://petsc.org/release/manualpages/PC/PCGAMG/>here</a>), which employ an implicit construction of transfer operations.
Moreover, the mesh hierarchies to be considered in this project should be generated by the available refinement routines (based on the work of <a href=https://www.oden.utexas.edu/media/reports/1996/9654.pdf>Plaza</a>), and not be applicable to general meshes without clear containment.</p><p>In addition to providing greater clarity for the user, the design should also, in principle, facilitate enhanced performance, or at the very least, more precise control over it.
This is because features are not utilized unless they have been employed by the user.</p><p>Nevertheless these specializations will not allow us to adress the discussed shared properties of geometric multigrid with $p$-multigrid and domain decomposition methods.
This should be a relatively straightforward process to implement once the geometric multigrid method has been implemented.</p><h2 id=interpolation-operators-and-dual-operators>Interpolation Operators and Dual Operators<a hidden class=anchor aria-hidden=true href=#interpolation-operators-and-dual-operators>#</a></h2><p>A first idea to approach the implementation of a geometric multigrid with the hope of an easy to attain proof of concept, came with the availability of the non-matching mesh interpolation routine of DOLFINx.
This routine implements a general interpolation operation between non matching meshes, and thus also non-matching, function spaces in general.
So we have already the implementation at hand to produce for two different finite element approximation spaces $V_\text{coarse}$ and $V_\text{fine}$ mappings
So a first approach might be to make use of these mappings for a first geometric multigrid implementation and refine it after.
Nevertheless, a more detailed examination reveals an inherent and irremediable defect in this setup.</p><p>Let us consider an one dimensional example.</p><p>$$
V_\text{coarse} = P^1 ( \left\lbrace 0, 1 \right\rbrace )
\quad \text{and} \quad
V_\text{fine} = P^1 \left( \left\lbrace 0, \frac{1}{2}, 1 \right\rbrace \right)
$$</p><p>with the non matching interpolations as restriction $R : V_\text{fine} \to V_\text{coarse}$ and prolongation $P : V_\text{coarse} \to V_\text{fine}$ operators, i.e.</p><p>$$
P = \begin{bmatrix}
1 & 0 \newline
\frac{1}{2} & \frac{1}{2} \newline
0 & 1
\end{bmatrix}
\quad \text{and} \quad
R = \begin{bmatrix}
1 & 0 & 0 \newline
0 & 0 & 1
\end{bmatrix}
$$</p><p>Especially the map $P$ is injective and $R$ is surjective, which fits our expectations.
But we loose one very important property that we require for transfer operators.
The restriction should be the adjoint of the prolongation, i.e. (for matrices)</p><p>$$
R = P^T \iff P = R^T.
$$</p><p>For the example this is not the case.
This breaks the properties of the multigrid operator - for example without duality we loose every mathematical ground of proving any properties of the multigrid operator matrix, such as for example the for convergence critical spectral radius.</p><h3 id=testing-discrete-adjoint-operators>Testing Discrete Adjoint Operators<a hidden class=anchor aria-hidden=true href=#testing-discrete-adjoint-operators>#</a></h3><p>The subtleties around the adjoint property do need end with this.
The requirement of the adjointness on the transfer operators and the implications on coefficients of the transferred functions preclude the possibility of recovering function scaling
Consequently, it is not feasible to expect that a combination of interpolations between the two spaces will yield a suitable transfer operator combination..</p><p>Furthermore, this suggests that meticulous attention must be paid to the criteria employed during the assessment of transfer operators, particularly with regard to the verification of implementations.
To illustrate, the constant one function is not recovered after it has been restricted and prolonged with suitable operators.
This is a consequence of our focus on the transfer of the residual, that is, an element of the dual space, not a function.</p><h2 id=an-interval-refinement-routine-for-dolfinx>An Interval Refinement Routine for DOLFINx<a hidden class=anchor aria-hidden=true href=#an-interval-refinement-routine-for-dolfinx>#</a></h2><p>The logical step to start with a geometric multigrid in the context of mesh hierarchies generated by refinement routines is, of course, the one-dimensional case, i.e. interval meshes.
However DOLFINx did not provide any such routine at that time.
So as a first major step, the implementation of a one-dimensional refinement routine was addressed, which resulted in a (merged) <a href=https://github.com/FEniCS/dolfinx/pull/3314>pull request</a>.</p><p>Let us consider a small example to illustrate what we need to do.
Given a mesh consisting of three vertices (bold) and two cells (or equivalently edges)</p><p><strong>0</strong> &mdash; 0 &mdash; <strong>1</strong> &mdash; 1 &mdash; <strong>2</strong> &mdash; 2 &mdash; <strong>3</strong>,</p><p>we want to perform a refinement on a set of marked edges $M$.
Let us first consider the case of uniform refinement, so we mark all edges for refinement, i.e. $M=\{ 0, 1, 2 \}$.
While in higher dimensions mesh refinement offers a great number of applicable refinement schemes to refine a marked edge, in one dimension the necessary operation is unique.
Each marked edge is to be split, i.e. a new vertex is to be introduced in the center and the former edge is to be split into two new finer/shorter edges.
For the former mesh we thus expect the fine mesh</p><p><strong>0</strong> &mdash; 0 &mdash; <strong>1</strong> &mdash; 1 &mdash; <strong>2</strong> &mdash; 2 &mdash; <strong>3</strong> &mdash; 3 &mdash; <strong>4</strong> &mdash; 4 &mdash; <strong>5</strong> &mdash; 5 &mdash; <strong>6</strong>.</p><p>At first glance, this seems like a very straightforward operation to implement, but a few caveats arising from parallel data structures with relabeling of indexes for locality and the for parallel use cases inevitable repartitioning make it surprisingly sophisticated to implement.</p><p>For the debugging of the code, especially in parallel, looking at visualizations of the meshes before and after refinement was a crucial step.
This was easy to do thanks to the handy <a href=https://github.com/nate-sime/febug>febug</a> tool, which makes visualizing different mesh entities straightforward and easy.</p><p><em>Coming soon</em>: detailed exaplanation of the algorithm introduced in <a href=https://github.com/FEniCS/dolfinx/pull/3314>PR 3314</a> including data stored in parallel, algorithm employed and output (parent cells)</p><h3 id=a-story-on-assertions-in-compiled-python-modules>A Story on Assertions in Compiled Python Modules<a hidden class=anchor aria-hidden=true href=#a-story-on-assertions-in-compiled-python-modules>#</a></h3><p>After discovering an initial bug in the merged code, resulting in an obscure crash of a Python test, we discovered a problem in the interaction with assertions and the Python runtime.
The bug was caused by the code hitting an assertion in the C++ part of the software, correctly due to a poorly designed test case.
However the <code>pytest</code> framework, which is used for unit and integration testing in the FEniCS project, did not catch this and only showed an inconclusive core dump.
This turned out to be a major and not trivially fixable problem.
If the C++ part, i.e. in a call of the compiled Python module, encounters an C-style assertion the runtime itself is killed, as this triggers a call to ´abort´.
In particular, the handling of the assertion is not passed back to the outer Python context which has systems in place to recover from this.
Since <code>abort</code> produces a <code>SIGABRT</code> signal that forcibly exits the program there is no easy way to fix this interaction.
However, if the Python module (i.e. the C++ code) is built in a <code>Debug</code> mode we would like to be able to debug from the Python side as well, which is then no longer possible.
This needs to be investigated further and remains an <a href=https://github.com/FEniCS/dolfinx/issues/3333>open issue</a>.</p><h3 id=unifying-the-refinement-interface>Unifying the Refinement Interface<a hidden class=anchor aria-hidden=true href=#unifying-the-refinement-interface>#</a></h3><p>After merging the one-dimensional refinement routine, we wanted to merge its interface with the previously available two- and three-dimensional Plaza refinement routines.
This resulted in many changes and simplifications to the interface.
It became more explicit and easier to use, resulting in an (open) <a href=https://github.com/FEniCS/dolfinx/pull/3322>pull request</a>.</p><p>One technical change that was introduced to facilitate this was the use of <code>std::optional</code>&rsquo;s for input and output parameters.
Previously these were not used and a &rsquo;no-set&rsquo; case was always handled separately leading to multiple different code paths.
In addition, this dispatching had to be present in the python module as well.
However, Nanobind (the Python exporter used in the DOLFINx project) however supports the <code>std::optionals</code> matching from the python optional <code>None</code> or value style for this.
So after the change, we no longer need to handle different parameter combinations in the Python module, this is all done in the C++ module.
These changes are part of another (open) <a href=https://github.com/FEniCS/dolfinx/pull/3328>pull request</a>.</p><h2 id=the-transfer-matrix>The Transfer Matrix<a hidden class=anchor aria-hidden=true href=#the-transfer-matrix>#</a></h2><p><em>Coming soon</em>: parallelization and ghost nodes, graph partitioning</p><h3 id=debugging-a-parallel-csr-matrix>Debugging a Parallel CSR Matrix<a hidden class=anchor aria-hidden=true href=#debugging-a-parallel-csr-matrix>#</a></h3><p>Compressed Sparse Row Major (CSR) matrices are a great data format for efficient computations and FEM matrix assemblies.
However, the data format is not easy to debug or visualize.
For debugging purposes the DOLFINx CSR matrix implementation has a <code>to_dense</code> functionality that translates the CSR format into a dense representation of the matrix for debugging purposes.
However, this functionality only really supported sequential calls, and dropped quite a bit of information in parallel runs.
Let us recap what the functionality used to provide and present its new functionality.</p><p>Given two parallel partitions $I = (i_0, \dots, i_n)$ and $J = (j_0, \dots, j_n)$ associated with the row and column distribution across the ranks, i.e. the process $p$, for some $0 \leq p &lt; n$, owns rows $[i_p, i_{p+1})$ and columns $[j_p, j_{p+1})$.
The <code>to_dense</code> function produced the dense subblock of the global matrix $A = (a_{ij})_{0\leq i &lt; i_n,\ 0 \leq j \leq j_n}$ which was strictly global, i.e. the submatrix</p><p>$$
\begin{bmatrix}
a_{i_p, j_p} & \dots & a_{i_p, j_{p+1}} \newline
\vdots & \ddots & \vdots \newline
a_{i_{p+1}, j_p} & \dots & a_{i_{p+1}, j_{p+1}}
\end{bmatrix}.
$$</p><p>However, this functionality drops from the dense representation all entries that are part of the local entries, and thus available on the given process rank $p$, that are in columns not owned by the current process $p$.
After the proposed changes <code>to_dense</code> now returns a dense representation of all locally owned rows (over all global columns), i.e. the submatrix we get on process $p$ is then</p><p>$$
\begin{bmatrix}
a_{i_p, 0} & \dots & a_{i_p, j_n} \newline
\vdots & \ddots & \vdots \newline
a_{i_{p+1}, 0} & \dots & a_{i_{p+1}, j_n}
\end{bmatrix}.
$$</p><p>These changes are part of a (open) <a href=https://github.com/FEniCS/dolfinx/pull/3354>pull request</a> and are required for debugging and testing the transfer matrix implementation alike.</p><h2 id=geometric-twogrid-example>Geometric Twogrid Example<a hidden class=anchor aria-hidden=true href=#geometric-twogrid-example>#</a></h2><p><em>Coming soon&mldr;</em></p><h2 id=general-code-contributions>General Code Contributions<a hidden class=anchor aria-hidden=true href=#general-code-contributions>#</a></h2><p>While the primary objective was the implementation of a geometric multigrid, a number of additional changes were made to different repositories. These changes are outlined below in chronological order.</p><h3 id=dolfinx---introduce-aliasing-for-mdspan-closedhttpsgithubcomfenicsdolfinxpull3116>DOLFINx - Introduce Aliasing for <code>mdspan</code> <a href=https://github.com/FEniCS/dolfinx/pull/3116>(Closed)</a><a hidden class=anchor aria-hidden=true href=#dolfinx---introduce-aliasing-for-mdspan-closedhttpsgithubcomfenicsdolfinxpull3116>#</a></h3><p>The <code>mdspan</code> library utilized by the FEniCS Project is based on the Kokkos <a href=https://github.com/kokkos/mdspan>reference implementation</a>.
To streamline the namespace switching process, depending on compiler support for either <code>std::experimental::mdspan</code> or <code>std::mdspan</code>, or no support at all the implementation introduces the macro <code>MDSPAN_IMPL_STANDARD_NAMESPACE</code>.
This results in unnecessarily lengthy calls, as it requires the repeated writing out of <code>MDSPAN_IMPL_STANDARD_NAMESPACE::mdspan</code> each time <code>mdspan</code> is used
In the pull request, the suggestion was to wrap this into a custom hiding layer, allowing for access via <code>dolfinx::common::mdspan</code>, regardless of what this dispatches to.
This approach would also enable the code to remain unchanged in the event of an STL version update.
Following a discussion, the proposed changes were rejected on the grounds that they constituted an approximation of a third-party library.</p><h3 id=basix---update-mdspan-mergedhttpsgithubcomfenicsbasixpull840>Basix - Update mdspan <a href=https://github.com/FEniCS/basix/pull/840>(Merged)</a><a hidden class=anchor aria-hidden=true href=#basix---update-mdspan-mergedhttpsgithubcomfenicsbasixpull840>#</a></h3><p>Update to new Kokkos single header <code>mdspan</code> changes.</p><h3 id=dolfinx---make-compile-time-options-compile-time-constants-mergedhttpsgithubcomfenicsdolfinxpull3246>DOLFINx - Make compile time options compile time constants <a href=https://github.com/FEniCS/dolfinx/pull/3246>(Merged)</a><a hidden class=anchor aria-hidden=true href=#dolfinx---make-compile-time-options-compile-time-constants-mergedhttpsgithubcomfenicsdolfinxpull3246>#</a></h3><p>Previously, the transformation of compiler flags in translation units was moved to header files in combination with the usage of <code>consteval</code>, which effectively made them true compile time constants.
The following example illustrates the idiom of the changes for a given CMake flag.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>consteval</span> <span class=kt>bool</span> <span class=nf>has_flag</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef FLAG
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=dolfinx---some-updates-for-mesh-generation-openhttpsgithubcomfenicsdolfinxpull3275>DOLFINx - Some updates for mesh generation <a href=https://github.com/FEniCS/dolfinx/pull/3275>(Open)</a><a hidden class=anchor aria-hidden=true href=#dolfinx---some-updates-for-mesh-generation-openhttpsgithubcomfenicsdolfinxpull3275>#</a></h3><p>While researching mesh-related data structures in DOLFINx for the project, I discovered several suboptimal code paths in the mesh generation code.
This PR addresses these issues, primarily through modernization, simplification, and additional testing.
The modernizations also made use of the previously (in the FEniCS Project) unused <a href=https://en.cppreference.com/w/cpp/ranges>ranges library</a>, this was the trigger for looking into further use cases of it, resulting in the following 12 pull requests.</p><h3 id=basix---update-to-stdranges-usage-mergedhttpsgithubcomfenicsbasixpull837>Basix - Update to std::ranges usage <a href=https://github.com/FEniCS/basix/pull/837>(Merged)</a><a hidden class=anchor aria-hidden=true href=#basix---update-to-stdranges-usage-mergedhttpsgithubcomfenicsbasixpull837>#</a></h3><p>Made use of all <code>C++20</code> available ranges algorithms in the Basix code base.</p><h3 id=basix---c23-support-revertedhttpsgithubcomfenicsbasixpull838>Basix - C++23 Support <a href=https://github.com/FEniCS/basix/pull/838>(Reverted)</a><a hidden class=anchor aria-hidden=true href=#basix---c23-support-revertedhttpsgithubcomfenicsbasixpull838>#</a></h3><p>Some important parts of the ranges library were missed in <code>C++20</code>, and are only available from <code>C++23</code> onward.
So to check general compatibility of the FEniCS packages with <code>C++23</code> we looked into the root dependency Basix and confirmed that we it is <code>C++23</code> ready in this PR.
This move to the <code>C++23</code> standard was later on reverted, and it was decided on to (not yet) switch to <code>C++23</code> but remain with <code>C++20</code> for now mainly due to lacking compiler support.</p><h3 id=dolfinx---update-to-stdranges-usage>DOLFINx - Update to <code>std::ranges</code> usage<a hidden class=anchor aria-hidden=true href=#dolfinx---update-to-stdranges-usage>#</a></h3><p>Modernization to range based algorithms across all of DOLFINx, split up into several PR&rsquo;s:</p><ul><li>Replace <code>std::sort</code> with <code>std::ranges::sort</code> <a href=https://github.com/FEniCS/dolfinx/pull/3293>(Merged)</a></li><li>Replace <code>std::fill</code> with <code>std::ranges::fill</code> <a href=https://github.com/FEniCS/dolfinx/pull/3294>(Merged)</a></li><li>Replace <code>std::lower/uper_bound</code> with <code>std::ranges::lower/uper_bound</code> <a href=https://github.com/FEniCS/dolfinx/pull/3295>(Merged)</a></li><li>Replace <code>std::for_each</code> with <code>std::ranges::for_each</code> <a href=https://github.com/FEniCS/dolfinx/pull/3296>(Merged)</a></li><li>Replace <code>std::transform</code> with <code>std::ranges::transform</code> <a href=https://github.com/FEniCS/dolfinx/pull/3297>(Merged)</a></li><li>Replace <code>std::set_*</code> with <code>std::ranges::set_*</code> <a href=https://github.com/FEniCS/dolfinx/pull/3298>(Merged)</a></li><li>Replace <code>std::copy</code> with <code>std::ranges::copy</code> <a href=https://github.com/FEniCS/dolfinx/pull/3299>(Merged)</a></li><li>Replace <code>std::min/max</code> with <code>std::ranges::min/max</code> <a href=https://github.com/FEniCS/dolfinx/pull/3300>(Merged)</a></li><li>Replace <code>std::unique</code> with <code>std::ranges::unique</code> <a href=https://github.com/FEniCS/dolfinx/pull/3315>(Merged)</a></li></ul><h3 id=rework-radix_sort-mergedhttpsgithubcomfenicsdolfinxpull3313>Rework <code>radix_sort</code> <a href=https://github.com/FEniCS/dolfinx/pull/3313>(Merged)</a><a hidden class=anchor aria-hidden=true href=#rework-radix_sort-mergedhttpsgithubcomfenicsdolfinxpull3313>#</a></h3><p>During the process of updating from <code>std::sort</code> to <code>std::ranges::sort</code>, it was observed that the custom DOLFINx implementation of radix sort <code>radix_sort</code> (which is utilized for performance-critical sorting of degree of freedom indices primarily) is not compatible with the ranges interface.
This pull request introduces a range-based radix_sort, which offers the same functionality as <code>std::ranges::sort</code>.
To achieve this, the operator-based approach used in the ranges library was followed, and a projection routine for the elements can be added.
This allowed for the removal of the previously hand-coded <code>argsort_radix</code> in DOLFINx, leaving only one instance of the <code>radix_sort</code> functionality.
Given its performance-critical nature, the changes were benchmarked <a href=https://github.com/schnellerhase/dolfinx/pull/24>here</a>.
The results demonstrated that the higher-quality code is also the faster one.</p><h3 id=favor-exterior_facet_indices-over-locate_entities_boundary-for-retrieving-complete-boundary-mergedhttpsgithubcomfenicsdolfinxpull3283>Favor <code>exterior_facet_indices</code> over <code>locate_entities_boundary</code> for retrieving complete boundary <a href=https://github.com/FEniCS/dolfinx/pull/3283>(Merged)</a><a hidden class=anchor aria-hidden=true href=#favor-exterior_facet_indices-over-locate_entities_boundary-for-retrieving-complete-boundary-mergedhttpsgithubcomfenicsdolfinxpull3283>#</a></h3><p>This pull request addresses the observation that when all boundary entities need to be selected in FEniCSx to construct a Dirichlet boundary condition on them, it is not necessary to filter these with a specific lambda as the default interface of <code>locate_entities_boundary</code> requires.
Instead, the <code>exterior_facet_indices</code> can be used, which simply returns all boundary facets.
This resulted in a (still ongoing) discussion on optional arguments in the DOLFINx code base and their implications for the exported Python module.</p><h3 id=strictly-maintenance-prs>Strictly Maintenance PR&rsquo;s<a hidden class=anchor aria-hidden=true href=#strictly-maintenance-prs>#</a></h3><ul><li>DOLFINx - Fix ruff check <a href=https://github.com/FEniCS/dolfinx/pull/3349>(Merged)</a></li><li>febug - Fix installation with <code>dolfinx</code> main <a href=https://github.com/nate-sime/febug/pull/13>(Merged)</a></li><li>FEniCS/web - Fix CI <a href=https://github.com/FEniCS/web/pull/187>(Merged)</a></li></ul><h2 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>#</a></h2><p>I would like to express my gratitude to the following individuals and institutions for their support and contributions:</p><p>Firstly I would like to the (previously mentioned) supervisors of the GSOC project, for their kind welcome to the community and receptivity to new ideas, as well as for fostering a generally constructive and engaging atmosphere for discussion.</p><p>I am indepted to <a href=https://finsberg.github.io/>Henrik N. Finsberg</a> (Senior Research Engineer, Simula Research Laboratory) and <a href=https://jsdokken.com/>Jørgen S. Dokken</a> (Senior Research Engineer, Simula Research Laboratory) for acting as my initial point of contact with the FEniCS project and for making me aware of the possibilty of a GSOC project.</p><p>Furthermore, I would be remiss if I did not acknowledge the contributions of all community members who provided assistance on the Slack channel or through comments and feedback on various pull requests.</p><p>During the GSOC period, I was fortunate to attend the <a href=https://fenicsproject.org/fenics-2024/>FEniCS conference 2024</a>, which I was able to do with the assistance of a NumFOCUS travel award.
Otherwise, it would not have been feasible to interact with all of the mentors and community members who were present in person.</p><p>In conclusion, I would like to express my gratitude to the Google Summer of Code program for providing me with the opportunity and financial support, which enabled me to pursue my academic interests and enhance my technical abilities with minimal constraints.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>© <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>